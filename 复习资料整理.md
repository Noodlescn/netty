<!--

JDK 相关：

八种基本数据类型:
    byte 
    short 
    int
    long
    float
    double
    boolean
    char

### 1, JAVA 集合相关
#### 1.1 ArrayList, LinkedList
    - 是否保证线程安全?
    - 底层数据结构
    - 插入和删除是否受元素位置的影响
    - 是否支持快速随机访问
    - 内存空间占用
    - 如何进行扩容,默认初始化空间是多少?

https://bugstack.cn/interview/2020/08/27/面经手册-第7篇-ArrayList也这么多知识-一个指定位置插入就把谢飞机面晕了.html
https://bugstack.cn/interview/2020/08/30/面经手册-第8篇-LinkedList插入速度比ArrayList快-你确定吗.html




#### 1.2 HashMap
    HashMap的数据结构(1.7、1.8的区别)
    HashMap的实现原理
    HashMap扩容为什么是2^n-1
    HashMap是线程安全的吗
    HashMap、HashTable是什么关系？

HashMap 1.7:
    - https://blog.csdn.net/carson_ho/article/details/79373026

HashMap 1.8:
    - https://blog.csdn.net/carson_ho/article/details/79373134

    https://bugstack.cn/interview/2020/08/07/面经手册-第3篇-HashMap核心知识-扰动函数-负载因子-扩容链表拆分-深度学习.html
    

- HashMap 数据结构:
  - 1.7 : 数组 + 单链表
  - 1.8 : 数组 + 链表 + 红黑树(当链表的深度达到8的时候,就会自动扩容把链表转成红黑树,把时间复杂度从O(n)变成O(logN))
    - JDK 1.8 优化的目的: 减少 Hash 冲突, 提高哈希表的存,取效率~~~~

- HashMap 重要参数: 容量, 负载因子(Load factor), 扰动函数, 扩容阈值
  - 默认容量: 16
  - 负载因子: 0.75
  - hash(key):
    - 处理的根本目的: 为了提高存储 key-value 的数组下标位置的随机性 和 分布均匀性,尽量避免出现hash值冲突;
    - 当 key == null 时, hash 值 = 0, 所以 HashMap 的 key 可为 null;
      - Hashtable 对 key 直接hashCode(), 若 key 为 null, 会抛出异常,所以Hashtable的 key 不为 null;
    - JDK 1.7 做了 9 次扰动处理 = 4 次位运算 + 5 次异或运算
    - JDK 1.8 做了 2 次扰动处理 = 1 次位运算 + 1 次异或运算
  - 扩容:
    - JDK 1.7: 
      - 单链表的头插法
      - 扩容时,转移数组的流程: 正向遍历, 逆向转移
      - 多线程并发执行 put() 操作,一旦出现扩容情况,容易出现 环形链表,从而在获取数据, 遍历链表时, 形成死循环(Infinite Loop), 即死锁的状态 = 线程不安全

```
=== JDK 1.7
static final int hash(Object k) {
    int h = 0;
    h ^= k.hashCode();
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}

=== JDK 1.8
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```


#### 1.3 StringBuffer 和 StringBuilder
- 有什么区别?
- 是线程安全的么?

https://bugstack.cn/interview/2020/09/17/面经手册-第11篇-StringBuilder-比-String-快-空嘴白牙的-证据呢.html


#### 1.4 队列
- 双端队列ArrayDeque
- 双端队列LinkedList
- 延时队列DelayQueue

https://bugstack.cn/interview/2020/09/03/面经手册-第9篇-队列是什么-什么是双端队列-延迟对列-阻塞队列-全是知识盲区.html


#### 1.4 Java 8 的新特性
- lambda表达式
- Functional Interfaces
- Optionals
- Stream 流
- Parallel-Streams 并行流

Java 8 中创建 Stream 流有几种方式?
https://www.cnblogs.com/binghe001/p/12961977.html
http://bugstack.cn/itstack-demo-any/2019/12/10/有点干货-Jdk1.8新特性实战篇(41个案例).html



### 2, 并发编程

#### 2.1 ThreadLocal 
    - 讲讲你对 ThreadLocal 的一些理解
    - ThreadLocal 有哪些应用场景?  全链路监控, 或者日志框架 MDC
    - 了解过 FastThreadLocal 么?
    
    - ThreadLocal 和 AOP 统计接口调用时长 (简历)

    - https://bugstack.cn/interview/2020/09/23/面经手册-第12篇-面试官-ThreadLocal-你要这么问-我就挂了.html
    - https://www.cnblogs.com/wang-meng/p/12856648.html    



#### 2.2 volatile
    - volatile 的作用和使用场景
    - volatile 如何保证指令重排
    - 什么情况下会发生指令重排




#### 2.3 synchronized
    - 一般用在什么场景
    - 实现原理
    - 锁升级过程(偏向锁, 轻量级锁, 重量级锁)
    - 这是 JVM 层面锁, 还是 JDK 层面锁?
    - 这是一种悲观锁,还是乐观锁?


#### 2.4 lock
    - 这是 JVM 层面锁,还是 JDK 层面锁
    - 这是一种悲观锁, 还是乐观锁
    - 是可重入锁么?


#### 2.5 ReentrantLock
    - 与 synchronized 相比较有什么不同?
    - ReentrantLock 与 Lock 的关系
    - 锁过程是否可中断, 与之对应的 synchronized 可中断么?


#### 2.6 CAS
    - Unsafe 类的作用
    - CAS 的理解(compareAndSet)
    - 什么是 ABA 问题?
    - CAS 的实现是什么? (AtomicInteger)

#### 2.7 AQS
    - 实现类有哪些? RenentrantLock,  Semaphore, CountDownLatch, CyclicBarrier
    - 实现了 AQS 的锁, 有哪些? 

    - 深入AQS原理： https://www.cnblogs.com/wang-meng/p/12816829.html
    - Fail-Fast 总结: https://www.cnblogs.com/wang-meng/p/5565150.html



### 3, 多线程

线程池

线程的周期

### 4, JVM

    Minor GC, Full GC, Major GC, Old GC:
        https://www.cnblogs.com/cnndevelop/p/12142638.html
    元空间：
    
    StrongReference, SoftReference, WeakReference, PhantomReference：
        - https://blog.csdn.net/thewindkee/article/details/102723838





Spring IOC 详解:
    https://morty.blog.csdn.net/article/details/108904418

Spring AOP 设计基本原理:
    https://louluan.blog.csdn.net/article/details/51095702
    https://louluan.blog.csdn.net/article/details/51155821


动态代理机制:
    https://louluan.blog.csdn.net/article/details/24589193


OkHttp3 基本原理:
    https://louluan.blog.csdn.net/article/details/90419804





RocketMQ:
    深入理解RocketMQ: https://louluan.blog.csdn.net/article/details/91368332



// TODO:

netty 
  nio 模型
  io 模型

springCloud

MQ

Zookeeper
    - CAP
    - BASE
    - 分布式事务，两阶段提交，三阶段提交

Redis：
    内存满，LRU


算法：
    快排
    二叉树
    B 树
    B+ 树
    递归
    动态规划
    skipList



    算法刷题: https://juejin.cn/post/6844904012987236359

    红黑树: https://blog.csdn.net/v_july_v/article/details/6105630


    


多线程编程：
    https://github.com/Noodlescn/concurrent

设计模式：
    单例模式：
        懒汉式，饿汉式，存在问题及修复方案



参考资料：
https://beginnersbook.com/
https://github.com/coderbruis/JavaSourceCodeLearning
https://github.com/coderbruis/Java-T-Shaped
https://www.cnblogs.com/itdragon/p/8506278.html
https://snailclimb.gitee.io/javaguide-interview/#/
quartz 源码解析: https://www.jianshu.com/p/f466e02e2e94