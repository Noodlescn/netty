<!--

JDK 相关：

八种基本数据类型:
    byte 
    short 
    int
    long
    float
    double
    boolean
    char

### 1, JAVA 集合相关
#### 1.1 ArrayList
- 基于数组实现, 如果通过无参构造的话,初始化容量为0; 当第一次插入元素时,才分配10(默认)个对象空间
- 扩容 3/2: newCapacity = oldCapacity + (oldCapacity >> 1)

https://bugstack.cn/interview/2020/08/27/面经手册-第7篇-ArrayList也这么多知识-一个指定位置插入就把谢飞机面晕了.html

#### 1.2 LinkedList
- 基于双向链表实现

https://bugstack.cn/interview/2020/08/30/面经手册-第8篇-LinkedList插入速度比ArrayList快-你确定吗.html


#### 1.3 HashMap
    HashMap的数据结构(1.7、1.8的区别)
    HashMap的实现原理
    HashMap扩容为什么是2^n-1
    HashMap是线程安全的吗
    HashMap、HashTable是什么关系？

HashMap 1.7:
    - https://blog.csdn.net/carson_ho/article/details/79373026

HashMap 1.8:
    - https://blog.csdn.net/carson_ho/article/details/79373134

    https://bugstack.cn/interview/2020/08/07/面经手册-第3篇-HashMap核心知识-扰动函数-负载因子-扩容链表拆分-深度学习.html

Hash Map 为什么线程不安全?
    - https://zhuanlan.zhihu.com/p/127147909
    

- HashMap 数据结构:
  - 1.7 : 数组 + 单链表
  - 1.8 : 数组 + 链表 + 红黑树(当链表的深度达到8的时候,就会自动扩容把链表转成红黑树,把时间复杂度从O(n)变成O(logN))
    - JDK 1.8 优化的目的: 减少 Hash 冲突, 提高哈希表的存,取效率~~~~

- HashMap 重要参数: 容量, 负载因子(Load factor), 扰动函数, 扩容阈值
  - 默认容量: 16
  - 负载因子: 0.75
  - hash(key):
    - 处理的根本目的: 为了提高存储 key-value 的数组下标位置的随机性 和 分布均匀性,尽量避免出现hash值冲突;
    - 当 key == null 时, hash 值 = 0, 所以 HashMap 的 key 可为 null;
      - Hashtable 对 key 直接hashCode(), 若 key 为 null, 会抛出异常,所以Hashtable的 key 不为 null;
    - JDK 1.7 做了 9 次扰动处理 = 4 次位运算 + 5 次异或运算
    - JDK 1.8 做了 2 次扰动处理 = 1 次位运算 + 1 次异或运算
  - 扩容:
    - JDK 1.7: 
      - 单链表的头插法
      - 扩容时,转移数组的流程: 正向遍历, 逆向转移
      - 多线程并发执行 put() 操作,一旦出现扩容情况,容易出现 环形链表,从而在获取数据, 遍历链表时, 形成死循环(Infinite Loop), 即死锁的状态 = 线程不安全

```
=== JDK 1.7
static final int hash(Object k) {
    int h = 0;
    h ^= k.hashCode();
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}

=== JDK 1.8
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```




ThreadLocal 源码： 
    - https://bugstack.cn/interview/2020/09/23/面经手册-第12篇-面试官-ThreadLocal-你要这么问-我就挂了.html
    - https://www.cnblogs.com/wang-meng/p/12856648.html    

AQS：
    - 深入AQS原理：https://www.cnblogs.com/wang-meng/p/12816829.html
    - 


2，JVM：
    Minor GC, Full GC, Major GC, Old GC:
        https://www.cnblogs.com/cnndevelop/p/12142638.html
    元空间：
    
    StrongReference, SoftReference, WeakReference, PhantomReference：
        - https://blog.csdn.net/thewindkee/article/details/102723838





Spring IOC 详解:
    https://morty.blog.csdn.net/article/details/108904418








// TODO:

netty 
  nio 模型
  io 模型

springCloud

MQ

Zookeeper
    - CAP
    - BASE
    - 分布式事务，两阶段提交，三阶段提交

Redis：
    内存满，LRU


算法：
    快排
    二叉树
    B 树
    B+ 树
    递归
    动态规划
    skipList



    算法刷题: https://juejin.cn/post/6844904012987236359

    红黑树: https://blog.csdn.net/v_july_v/article/details/6105630


java 8 新方法：
    http://bugstack.cn/itstack-demo-any/2019/12/10/有点干货-Jdk1.8新特性实战篇(41个案例).html


多线程编程：
    https://github.com/Noodlescn/concurrent

设计模式：
    单例模式：
        懒汉式，饿汉式，存在问题及修复方案



参考资料：
https://beginnersbook.com/
https://github.com/coderbruis/JavaSourceCodeLearning
https://github.com/coderbruis/Java-T-Shaped
https://www.cnblogs.com/itdragon/p/8506278.html
https://snailclimb.gitee.io/javaguide-interview/#/
quartz 源码解析: https://www.jianshu.com/p/f466e02e2e94