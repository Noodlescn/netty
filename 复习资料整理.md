<!--

JDK 相关：

八种基本数据类型:
    byte 
    short 
    int
    long
    float
    double
    boolean
    char

### 1, JAVA 集合相关
#### 1.1 ArrayList, LinkedList
    - 是否保证线程安全?
    - 底层数据结构
    - 插入和删除是否受元素位置的影响
    - 是否支持快速随机访问
    - 内存空间占用
    - 如何进行扩容,默认初始化空间是多少?
    - - Fail-fast: 是 Java 集合中的一种错误机制, 当多个线程对同一个集合的内容进行操作时,就可能会产生fail-fast事件
        当某一个线程A通过iterator去遍历某集合的过程中,若该集合的内容被其他线程所改变了; 那么线程A访问集合时,就会抛出
        ConcurrentModificationException异常,产生 fail-fast 事件

https://bugstack.cn/interview/2020/08/27/面经手册-第7篇-ArrayList也这么多知识-一个指定位置插入就把谢飞机面晕了.html
https://bugstack.cn/interview/2020/08/30/面经手册-第8篇-LinkedList插入速度比ArrayList快-你确定吗.html

Fail-fast 机制: https://blog.csdn.net/chenssy/article/details/38151189



#### 1.2 HashMap
    HashMap的数据结构(1.7、1.8的区别)
    HashMap的实现原理
    HashMap扩容为什么是2^n-1
    HashMap是线程安全的吗
    HashMap、HashTable是什么关系？

HashMap 1.7:
    - https://blog.csdn.net/carson_ho/article/details/79373026

HashMap 1.8:
    - https://blog.csdn.net/carson_ho/article/details/79373134

    https://bugstack.cn/interview/2020/08/07/面经手册-第3篇-HashMap核心知识-扰动函数-负载因子-扩容链表拆分-深度学习.html
    

- HashMap 数据结构:
  - 1.7 : 数组 + 单链表
  - 1.8 : 数组 + 链表 + 红黑树(当链表的深度达到8的时候,就会自动扩容把链表转成红黑树,把时间复杂度从O(n)变成O(logN))
    - JDK 1.8 优化的目的: 减少 Hash 冲突, 提高哈希表的存,取效率~~~~

- HashMap 重要参数: 容量, 负载因子(Load factor), 扰动函数, 扩容阈值
  - 默认容量: 16
  - 负载因子: 0.75
  - hash(key):
    - 处理的根本目的: 为了提高存储 key-value 的数组下标位置的随机性 和 分布均匀性,尽量避免出现hash值冲突;
    - 当 key == null 时, hash 值 = 0, 所以 HashMap 的 key 可为 null;
      - Hashtable 对 key 直接hashCode(), 若 key 为 null, 会抛出异常,所以Hashtable的 key 不为 null;
    - JDK 1.7 做了 9 次扰动处理 = 4 次位运算 + 5 次异或运算
    - JDK 1.8 做了 2 次扰动处理 = 1 次位运算 + 1 次异或运算
  - 扩容:
    - JDK 1.7: 
      - 单链表的头插法
      - 扩容时,转移数组的流程: 正向遍历, 逆向转移
      - 多线程并发执行 put() 操作,一旦出现扩容情况,容易出现 环形链表,从而在获取数据, 遍历链表时, 形成死循环(Infinite Loop), 即死锁的状态 = 线程不安全

```
=== JDK 1.7
static final int hash(Object k) {
    int h = 0;
    h ^= k.hashCode();
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}

=== JDK 1.8
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

#### 1.2.1 ConcurrentHashMap



#### 1.3 StringBuffer 和 StringBuilder
- 有什么区别?
- 是线程安全的么?

https://bugstack.cn/interview/2020/09/17/面经手册-第11篇-StringBuilder-比-String-快-空嘴白牙的-证据呢.html


#### 1.4 Java 8 的新特性
- lambda表达式
- Functional Interfaces
- Optionals
- Stream 流
- Parallel-Streams 并行流

Java 8 中创建 Stream 流有几种方式?
https://www.cnblogs.com/binghe001/p/12961977.html
http://bugstack.cn/itstack-demo-any/2019/12/10/有点干货-Jdk1.8新特性实战篇(41个案例).html



### 2, 并发编程

#### 2.1 ThreadLocal 
    - 讲讲你对 ThreadLocal 的一些理解
    - ThreadLocal 有哪些应用场景?  全链路监控, 或者日志框架 MDC
    - 了解过 FastThreadLocal 么?
    
    - ThreadLocal 和 AOP 统计接口调用时长 (简历)

    - https://bugstack.cn/interview/2020/09/23/面经手册-第12篇-面试官-ThreadLocal-你要这么问-我就挂了.html
    - https://www.cnblogs.com/wang-meng/p/12856648.html    
    - 深入剖析 ThreadLocal： https://www.cnblogs.com/dolphin0520/p/3920407.html
    - ThreadLocal 为什么会内存泄漏： https://blog.csdn.net/thewindkee/article/details/89390145

Java 中创建线程的方式: https://www.cnblogs.com/noteless/p/10354753.html
线程的状态: https://www.cnblogs.com/noteless/p/10372674.html
Java 内存模型JMM: https://www.cnblogs.com/noteless/p/10401193.html

FastThreadLocal 实现原理分析: https://blog.csdn.net/mycs2012/article/details/90898128
FastThreadLocal 原理: https://www.jianshu.com/p/6adfa89ed06e


#### 2.2 volatile
    - volatile 的作用和使用场景
    - volatile 如何保证指令重排
    - 什么情况下会发生指令重排
    
https://bugstack.cn/interview/2020/10/21/面经手册-第14篇-volatile-怎么实现的内存可见-没有-volatile-一定不可见吗.html

final 与 volatile 线程安全问题: https://blog.csdn.net/THE___BEST/article/details/78008260
深入理解java内存模型: https://www.infoq.cn/minibook/java_memory_model

#### 2.3 synchronized
    - 一般用在什么场景
    - 实现原理
    - 锁升级过程(偏向锁, 轻量级锁, 重量级锁)
    - 这是 JVM 层面锁, 还是 JDK 层面锁?
    - 这是一种悲观锁,

https://bugstack.cn/interview/2020/10/28/面经手册-第15篇-码农会锁-synchronized-解毒-剖析源码深度分析.html

多线程协作wait 和 notify: https://www.cnblogs.com/noteless/p/10468834.html
虚假唤醒: https://www.zhihu.com/question/50892224
sleep, yield, 以及join方法: https://www.cnblogs.com/noteless/p/10443446.html


不可不说的Java"锁"事: https://tech.meituan.com/2018/11/15/java-lock.html
    - 自旋锁,三种常见锁形式: 
      - TicketSpinLock
      - CLHlock
      - MCSlock: https://stefan.blog.csdn.net/article/details/108750554


高并发与多线程: https://blog.csdn.net/uftjtt/category_7640713.html
    synchronized 实现原理: https://blog.csdn.net/uftjtt/article/details/80200343
    Java 的对象模型: https://blog.csdn.net/uftjtt/article/details/80200553
    Java 的对象头: https://blog.csdn.net/uftjtt/article/details/80249489
    深入理解多线程, Moniter 的实现原理: https://blog.csdn.net/uftjtt/article/details/80250182
    Java 虚拟机的锁优化技术: https://blog.csdn.net/uftjtt/article/details/80251277



java 锁底层原理: https://juejin.cn/post/6872989550868856840

聊聊Java的几把JVM级锁: https://www.infoq.cn/article/4wofifidqz076zdaiau6 


#### 2.4 Lock
    -  JDK 层面锁
    - 这是一种悲观锁
    - 是可重入锁么?


// TODO: 待看

Lock接口与synchronized对比: https://www.cnblogs.com/noteless/p/10481286.html
synchronized锁和Lock锁: https://www.zhihu.com/question/332327455
Java 锁的那些事儿: https://www.infoq.cn/article/DOvfyp8kFP5YPdaTAJFF?utm_source=related_read_bottom&utm_medium=article


#### 2.5 ReentrantLock
    - 与 synchronized 相比较有什么不同?
    - ReentrantLock 与 Lock 的关系
    - 锁过程是否可中断, 与之对应的 synchronized 可中断么?

ReentrantLock 可中断锁: https://blog.csdn.net/dongyuxu342719/article/details/94395877
ReentrantLock 可重入锁的使用: https://zhuanlan.zhihu.com/p/88884729
StampedLock 源码分析: https://juejin.cn/post/6844903865154797581
        https://www.cnblogs.com/tong-yuan/p/StampedLock.html


#### 2.6 CAS
    - Unsafe 类的作用
    - CAS 的理解(compareAndSet)
    - 什么是 ABA 问题?  AtomicStampedReference
    - CAS 的实现是什么? (AtomicInteger)
    - 乐观锁实现方式

乐观锁与悲观锁: https://juejin.cn/post/6844903639207641096

Java魔法类: Unsafe应用解析: https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html

比AtomicLong更优秀的LongAddr: https://www.cnblogs.com/wang-meng/p/12892695.html



#### 2.7 AQS
    - 实现类有哪些? RenentrantLock,  Semaphore, CountDownLatch, CyclicBarrier
    - 实现了 AQS 的锁, 有哪些? 

    - 深入AQS原理： https://www.cnblogs.com/wang-meng/p/12816829.html

从ReentrantLock的实现看AQS原理及应用: https://tech.meituan.com//tags/java.html

AQS 源码解读: https://stefan.blog.csdn.net/article/details/108817678



### 3, 多线程



线程池

学会线程池: https://www.cnblogs.com/wang-meng/p/12945703.html

Java 线程池实现原理及美团实践: https://tech.meituan.com//tags/java.html

线程的周期

### 4, JVM

    Minor GC, Full GC, Major GC, Old GC:
        https://www.cnblogs.com/cnndevelop/p/12142638.html
    元空间：
    
    StrongReference, SoftReference, WeakReference, PhantomReference：
        - https://blog.csdn.net/thewindkee/article/details/102723838

从实际案例聊聊Java应用的GC优化: https://tech.meituan.com/2017/12/29/jvm-optimize.html


Java中9种常见的CMS GC问题分析与解决: https://tech.meituan.com/2020/11/12/java-9-cms-gc.html

SafePoint 和 Stop the world: https://xie.infoq.cn/article/63ea6c31a634c07b624f7bdba



#### 1.4 队列
- 双端队列ArrayDeque
- 双端队列LinkedList
- 延时队列DelayQueue

https://bugstack.cn/interview/2020/09/03/面经手册-第9篇-队列是什么-什么是双端队列-延迟对列-阻塞队列-全是知识盲区.html

高性能队列 Disruptor: https://tech.meituan.com/2016/11/18/disruptor.html



死磕 java 并发: https://chenssy.blog.csdn.net/article/details/81154894


Spring 框架的设计理念与设计模式分析: https://blog.csdn.net/uftjtt/article/details/80481912


Spring IOC 详解:
    https://morty.blog.csdn.net/article/details/108904418
    https://blog.csdn.net/uftjtt/article/details/80647848

Spring AOP 设计基本原理:
    https://louluan.blog.csdn.net/article/details/51095702
    https://louluan.blog.csdn.net/article/details/51155821

Spring 如何创建一个Bean：https://blog.csdn.net/thewindkee/article/details/104272555

Tomcat 类加载器：
    https://blog.csdn.net/thewindkee/article/details/97056000

Spring 中如何解决循环依赖：
    - https://blog.csdn.net/thewindkee/article/details/105186842


动态代理机制:
    https://louluan.blog.csdn.net/article/details/24589193


OkHttp3 基本原理:
    https://louluan.blog.csdn.net/article/details/90419804


Mybatis 缓存解析: https://blog.csdn.net/uftjtt/article/details/80265214



RocketMQ:
    深入理解RocketMQ: https://louluan.blog.csdn.net/article/details/91368332

Spring 容器的基本实现: https://blog.csdn.net/uftjtt/article/details/79896110



// TODO:

netty 
  nio 模型
  io 模型

springCloud

MQ

Zookeeper
    - CAP
    - BASE
    - 分布式事务，两阶段提交，三阶段提交

    - zookeeper 分布式锁原理：
      - https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247484027&idx=1&sn=d3ec68611979f436c2b90fe222ad8633&chksm=fba6ea78ccd1636ee23a387c845eacd92f2a185747b22068192d9fd818c5c166e3057dd43673&mpshare=1&scene=24&srcid=#rd

Redis：
    内存满，LRU
    https://juejin.cn/post/6872953483511726087
    https://magi003769.github.io/post/LRU%E5%92%8CLinkedHashMap/


算法：
    快排
    二叉树
    B 树
    B+ 树
    递归
    动态规划
    skipList

    二叉查找树: https://www.cnblogs.com/skywang12345/p/3576328.html



    算法刷题: https://juejin.cn/post/6844904012987236359

    红黑树: https://blog.csdn.net/v_july_v/article/details/6105630


高并发常见的限流方式：
    https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&mid=2648933212&idx=1&sn=b1e8f65d4673bd3cf64c2d6a00645ba9&chksm=88621b62bf15927422958029a1d240198082104d6e50d15dd33c5d3cf5af2195050b772782ec&token=870491352&lang=zh_CN&scene=21#wechat_redirect
    
分布式锁 + 分段锁：
    https://blog.csdn.net/eluanshi12/article/details/84616173
    https://www.huaweicloud.com/articles/43d469d97cf2f1c8f0395a4a06b2452e.html

多线程编程：
    https://github.com/Noodlescn/concurrent

设计模式：
    单例模式：
        懒汉式，饿汉式，存在问题及修复方案


    双重检查锁定与延迟初始化: https://www.infoq.cn/article/double-checked-locking-with-delay-initialization


参考资料：
https://beginnersbook.com/
https://github.com/coderbruis/JavaSourceCodeLearning
https://github.com/coderbruis/Java-T-Shaped
https://www.cnblogs.com/itdragon/p/8506278.html
https://snailclimb.gitee.io/javaguide-interview/#/
quartz 源码解析: https://www.jianshu.com/p/f466e02e2e94
java 并发编程的艺术: http://itmyhome.com/java-concurrent-programming/java-concurrent-programming.pdf
高级岗面试: https://xie.infoq.cn/article/7116114c1ac8dc598346d8518
JavaTutorials: https://www.javamex.com/